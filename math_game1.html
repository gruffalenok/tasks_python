<html>
<head>
<meta charset="utf-8">
  <title>Математические игры на клетчатом поле</title>
<style>
   body {  font-size: 130%;
           margin-top: 2em;
           margin-left: 4em;
		   margin-right: 4em;}
   pre  {  background-color: #eee;
           padding-top: 10;
	       padding-bottom: 10;}
</style>   
 
</head>
<body>
<h2>Математические игры на клетчатом поле</h2>

<p>Имеется поле M x N клеток.В нижнем левом углу поля стоит "хромая ладья", которая может ходить только вверх и вправо. Два игрока по-очереди перемещают ладью. Проигрывает тот, кто не может сделать очередной ход.</p>
<p>Варианты игры: вместо "хромой ладьи" может быть "хромой король", "хромой ферзь", "хромой конь", "хромой верблюд"...</p>
<h4>Задание:</h4>
<p><strong>A. </strong> Нарисуйте поле для игры. Сделайте управление, позволяющее игрокам по-очереди перемещать фигуру. Программа должна автоматически отслеживать очерёдность хода и конец игры. Должна быть возможность начать игру заново.  </p>
<p>Ниже приведён текст программы, в котором определяется класс <em>Chessman</em> и подклассы <em>Rook</em>, <em>King</em> и <em>Queen</em>. Скопируйте текст программы и запустите её. </p>
<ol>
Измените прграмму так, чтобы 
<li>Программа рисовала клетчатое поле.</li>
<li>В начале игры фигура стояла в центре левой нижней клетки.</li>
<li>Фигура перемещалась в ту клетку, по которой щёлкнули мышкой.</li>
<li>Фигура перемещалась только в том случае, если ходить в эту клетку можно по правилам игры.</li>
<li>Программа писала, чей ход.</li>
<li>Можно было начать игру снова, используя ту же фигуру.</li>
<li>Можно было начать игру снова, используя другую фигуру.</li>
</ol>
<pre>
# Менять нужно места, отмеченные словами "Мой код"
from tkinter import *


def draw_field():
    # Функция draw_field() должна рисовать клетчатое поле шириной Nx клеток и высотой Ny клеток
    ##########################################################################
    #  Мой код
    ##########################################################################
    canv.create_line(Margin, Margin, Margin, YMAX - Margin, fill='blue')
    canv.create_line(Margin, Margin, XMAX - Margin, Margin, fill='blue')

    ##########################################################################


def new_move(event):
    # Функция new_move(event) должна вычислять координаты клетки, в которую щёлкнули мышкой,
    # считая с левого нижнего угла, и передавать управление объекту chessman.
    # Если мышкой щёлкнули на полях, функция ничего не делает.
    global chessman
    ##########################################################################
    #  Мой код
    ##########################################################################
    r = 5
    canv.create_oval(event.x - r, event.y + r, event.x + r, event.y - r, fill='red')
    x_new = 0
    y_new = 0
    ##########################################################################
    if chessman.check_move(x_new, y_new):
        chessman.change_pos(x_new, y_new)


def new_rook():
    # Если класс объекта, на который ссылается переменная chessman, Rook,
    # то функция new_rook() начинает новую игру.
    # Если класс другой, то удаляется старое изображение и создаётся новый объект класса Rook
    # Используйте функцию type() или isinstance()
    global chessman
    ##########################################################################
    #  Мой код
    ##########################################################################

    ##########################################################################

def new_king():
    # Если класс объекта, на который ссылается переменная chessman, King,
    # то функция new_rook() начинает новую игру.
    # Если класс другой, то удаляется старое изображение и создаётся новый объект класса King
    # Используйте функцию type() или isinstance()
    global chessman
    ##########################################################################
    #  Мой код
    ##########################################################################

    ##########################################################################


def new_queen():
    # Если класс объекта, на который ссылается переменная chessman, Queen,
    # то функция new_rook() начинает новую игру.
    # Если класс другой, то удаляется старое изображение и создаётся новый объект класса Queen
    # Используйте функцию type() или isinstance()
    global chessman
    ##########################################################################
    #  Мой код
    ##########################################################################

    ##########################################################################


class Chessman():
    # В этом классе определяются все свойства и методы фигуры, которую двигают игроки,
    # кроме проверки, можно ли сделать такой ход.

    def __init__(self, x_pos=0, y_pos=0, size=20, color='green'):
        self.x_pos = x_pos  # номер клетки по горизонтали, считая с нижнего левого угла
        self.y_pos = y_pos  # номер клетки по вертикали, считая с нижнего левого угла
        self.size = size  # размер изображения (кружочка)
        self.color = color  # цвет изображения
        self.first_gamer = True  # True, если должен ходить первый игрок
        text.config(text='Ход первого игрока')
        # Вычисляются координаты x, y изображения и рисуется кружочек в середине начальной клетки
        ##########################################################################
        #  Мой код
        ##########################################################################
        x = Margin
        y = Margin
        self.image = canv.create_oval(x, y, x + self.size, y - self.size, fill=self.color)
        ##########################################################################

    def delete_image(self):
        # Функция delete_image() удаляет изображение фигуры с холста
        canv.delete(self.image)

    def change_pos(self, x_new, y_new):
        # Функция change_pos() перемещает изображение фигуры в клетку с координатами x_new и y_new,
        # считая от левого нижнего угла,
        # меняет значения self.x_pos и self.y_pos,
        # меняет игрока
        ##########################################################################
        #  Мой код
        ##########################################################################
        canv.move(self.image, 20, 20)
        ##########################################################################

    def new_game(self):
        # Функция new_game() перемещает фигуру в начальную позицию и устанавливает ход первого игрока
        self.change_pos(0, 0)
        self.first_gamer = True
        text.config(text='Ход первого игрока')

    def check_move(self, x_new, y_new):
        # Функция check_move() должна переопределяться в подклассах
        return True


class Rook(Chessman):
    # Хромая ладья
    def check_move(self, x_new, y_new):
        # Функция check_move() даёт ответ True, если данную фигуру можно переместить в клетку с номером x_new, y_new
        ##########################################################################
        #  Мой код
        ##########################################################################
        return True
        ##########################################################################


class King(Chessman):
    # Хромой король
    def check_move(self, x_new, y_new):
        # Функция check_move() даёт ответ True, если данную фигуру можно переместить в клетку с номером x_new, y_new
        ##########################################################################
        #  Мой код
        ##########################################################################
        return True
        ##########################################################################


class Queen(Chessman):
    # Хромой ферзь
    def check_move(self, x_new, y_new):
        # Функция check_move() даёт ответ True, если данную фигуру можно переместить в клетку с номером x_new, y_new
        ##########################################################################
        #  Мой код
        ##########################################################################
        return True
        ##########################################################################

# Начало программы
Margin = 50  # Размер полей
Cell_size = 50  # Сторона клеточки
print('Число клеток в ширину: ')
Nx = int(input())
print('Число клеток в высоту: ')
Ny = int(input())

# Ширина и высота холста
XMAX = Nx * Cell_size + Margin * 2
YMAX = Ny * Cell_size + Margin * 2

# создаём графическое окно
root = Tk()
# создаём холст в окне
canv = Canvas(root, width=XMAX, height=YMAX, bg="lightblue")

# Создаём кнопки и надпись
button1 = Button(root, text="Хромая ладья", command=new_rook)  # при нажатии на кнопку запускается функция draw()
button2 = Button(root, text="Хромой король", command=new_king)
button3 = Button(root, text="Хромой ферзь", command=new_queen)
text = Label(text="Ход первого игрока", font=("Comic Sans MS", 24, "bold"), bd=10)

# Созданные объекты размещаются в окне
text.grid(row=0, column=0, columnspan=3)
canv.grid(row=1, column=0, columnspan=3)
button1.grid(row=2, column=0)
button2.grid(row=2, column=1)
button3.grid(row=2, column=2)

# Рисуем клеточки
draw_field()

# Создаём фигуру для игры
chessman = Rook()

# задаём действие для левой клавиши мыши
canv.bind("&lt;Button-1&gt;", new_move)

# выводим окно на экран
root.mainloop()

</pre>
<hr>
<p><strong>B. </strong> Напишите программу, которая автоматически отмечает на игровом поле выигрышные и проигрышные позиции.</p> 
<hr>
<p><strong>С. </strong> Напишите программу, которая предлагает пользователю выбрать, первым он играет, или вторым, и играет за другого игрока оптимальным образом.</p> 
<hr>


</body>
</html>
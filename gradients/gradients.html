<html>
<head>
<meta charset="utf-8">
  <title>Растровые изображения (библиотека PIL)</title>
<style>
   body {  background-color: #025;
           color: #ddd;
           font-size: 130%;
           margin-top: 2em;
           margin-left: 4em;
		   margin-right: 4em;}
   pre  {  background-color: #eee;
           color: #000;
           padding-top: 10;
	       padding-bottom: 10;}
</style>   
 
</head>
<body>
<h2>Градиенты: раскрашиваем пиксели в бибиотеке PIL</h2>
<h4>Пример работы с библиотекой PIL</h4>

<p>Пример программы, создающей полноцветное растровое изображение (RGB) и рисующей фигуры с помощью модуля PIL (обратите внимание на скобки в параметрах функции!). А ещё обратите внимание, что при увеличении на границе фигур мы увидим "ступеньки" - отдельные раскрашенные пиксели. </p><p>
<pre>
from PIL import Image, ImageDraw

XMAX =600
YMAX = 500

x0 = 30
y0 = 100
x1 = 400
y1 = 200

img = Image.new("RGB", (XMAX, YMAX), (0, 50, 100)) # Создаём новое растровое изображение
img_draw = ImageDraw.Draw(img) # Создаём объект, который позволяет рисовать поверх изображения img
img_draw.rectangle((x0, y0, x1, y1), outline=None, fill=(170,170,170)) # Прямоугольник без контура
img_draw.polygon((x0+100, y0+150, x1+100, y1+150, x0+100, y1+150), outline=(0, 256, 256), fill=(230,230,0))
img_draw.line((0, 0, 400, 400), fill=(255, 255, 0))
img_draw.line((-100, 0, 500, 600), fill=(255, 255, 0))
img_draw.ellipse((450, 150, 550, 250), fill="#FF00FF")
img_draw.rectangle((450, 150, 550, 250), outline="#FF0000", width =2) # Прозрачный прямоугольник
img.save('picture1.png')   # Сохраняем картинку в файл
img.show() # Открывается стандартная программа для показа изображений
</pre></p>
<h3>Градиентные заливки, использующие оттенки серого</h3>
<p>В следующем примере создаётся изображение в цветовой модели "Grayscale". Каждую точку этого изображения можно покрасить в один из 256 цветов - от 0 (чёрный) до 256 (белый). Параметр fill в функции point() задаёт цвет точки, который в данном примере равен координате х.
</p><p>
<pre>
from PIL import Image, ImageDraw

w = 256
h = 256
img = Image.new("L", (w, h))
img_draw = ImageDraw.Draw(img)

for y in range(256):
    for x in range(256):
        img_draw.point((x, y), fill=x)
img.show()
</pre></p>
<h4>Задание</h4>
<p><strong>А. </strong> Используя этот пример, нарисуйте следующие картинки:
</p><p>
1) горизонтальный градиент от белого к чёрному
</p><p>
2) вертикальный градиент от чёрного к белому
</p><p>
3) вертикальный градиент от белого к чёрному
</p><p>
4) градиент, в котором цвета меняются одновременно и по горизонтали, и по вертикали.</p> 
<p>
<strong>Подсказка:</strong> В следующих примерах используйте нахождение остатка, целочисленное деление, умножение, модуль числа (функция abs()) - не всё сразу, конечно. 
</p>
<p>5)<img src='gray2.png'> </p>
<p>6)<img src='gray3.png'> </p>
<p>7)<img src='gray4.png'> </p>
<p>8)<img src='gray5.png'> </p>
<p>9)<img src='gray6.png'> </p>
<p>10)<img src='gray11.png'> </p>
<p>11)<img src='gray7.png'> </p>
<p>12)<img src='gray9.png'> </p>
<p>13)<img src='gray8.png'> </p>
<hr>
<h3>Градиентные заливки в цветовой модели RGB</h3>
<p>На полноцветной картинке цвет каждой точки задаётся тремя числами: яркостью красного, зелёного и синего луча, или "канала". По умолчанию цвет фона чёрный.
</p><p>
<pre>
from PIL import Image, ImageDraw

w = 256
h = 256
img = Image.new("RGB", (w,h))
img_draw = ImageDraw.Draw(img)
for y in range(256):
    for x in range(256):
        img_draw.point((x, y), fill=(255, 150, 0))
img.show()
</pre></p>
<p><strong>В. </strong> Создайте вертикальный градиент 1) от красного к жёлтому, 1) от жёлтого к красному, 3) от голубого к зелёному, 4) ещё какой-нибудь.</p>
<hr>
<p><strong>С. </strong> 1) Создайте картинку, в которой яркость канала красного меняется по горизонтали, яркость канала зелёного - по вертикали, яркость синего постоянна.</p>
<p>2) Создайте картинку, в которой яркость всех каналов изменяется (объедините три формулы из задания А). Может получиться, например, так:
</p>
<p><img src='26.png'> </p>
<hr>
<p><strong>D. </strong> Создайте картинку, в которой яркость всех каналов изменяется. Например, такую:</p>
<p><img src='1.png'> </p>
<p>1) Измените часть картинки так, чтобы в середине появился прямоугольник, раскрашенный по-другому (пиксели с краю менять не надо).
Например, так:
</p>
<p><img src='2.png'> </p>
<p>2) Измените нижнюю левую часть картинки, а верхнюю правую оставьте неизменной.
Например, так:
</p>
<p><img src='4.png'> </p>
<p>
<strong>Подсказка:</strong> Верхняя граница цикла, перебирающего точки в одном ряду, зависит от номера ряда.
</p>
<p>3) Измените нижнюю правую часть картинки, а верхнюю левую оставьте неизменной.
Например, так:
</p>
<p><img src='5.png'> </p>
<p>
<strong>Подсказка:</strong> Нижняя граница цикла, перебирающего точки в одном ряду, зависит от номера ряда.
</p>
<hr>
<p>Если использовать внутри цикла условный оператор, можно "на ходу" решать, какие пиксели каким градиентом закрашивать.
<br>
Или сначала закрасить всю картинку, а потом поменять её часть.</p>
<p><strong>Е. </strong>Создайте следующие картинки (градиентная заливка может быть любой):
</p>
<p>1) <img src='6.png'> </p>
<p>2) <img src='8.png'> </p>
<p>3) <img src='7.png'> </p>
<p>4) <img src='gradient1.png'> </p>
<p>5) <img src='gradient2.png'> </p>
<p>6) <img src='gradient4.png'> </p>
<p>7) <img src='gradient5.png'> </p>
<p>8) <img src='gray10.png'> </p>
<hr>

<p><strong>F.</strong> Напишите функцию, добавляющую к картинке шум. Яркость всех составляющих (R, G, B) каждого пикселя меняется на случайную величину в заданном интервале.
<br>
Примените данную функцию к созданным ранее картинкам. Получится, например, так:
<p><img src='9.png'> </p>
<p><img src='10.png'> </p>
<hr>
<p><strong>G. Цветовая иллюзия. Круги - разноцветные?</strong> </p> 
<p><img src='illusions4.png'> </p><p>
Фон состоит из тонких полосок красного, зелёного и синего цветов. Поверх фона располагаются одинаковые серые "шарики" (напишите отдельную функцию для рисования такого шарика поверх уже существующего фона). Поверх каждого "шарика" рисуются полоски только одного цвета: красного, зелёного или синего (для этого тоже удобно создать отдельную функцию). Кажущийся цвет круга будет зависеть от цвета нарисованных поверх него полосок.
 </p>
<p><img src='illusions4a.png'> </p>
<hr>
</body>
</html>
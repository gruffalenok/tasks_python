<html>
<head>
<meta charset="utf-8">
  <title>Задачи про лабиринты</title>
<style>
   body {  font-size: 130%;
           margin-top: 2em;
           margin-left: 4em;
		   margin-right: 4em;}
   pre  {  background-color: #eee;
           padding-top: 10;
	       padding-bottom: 10;}
</style>   
 
</head>
<body>
<h2>Генератор правильных лабиринтов</h2>
<p><img src='labirint1.png' align='right'></p>
<h3>Что такое правильный лабиринт?</h3>
<p><em>Что такое лабиринт?</em> - Для нас это будут клетки, по которым можно перемещаться, разделённые стенками, через которые пройти нельзя.</p><p>
<em>Что такое правильный лабиринт?</em> - Это такой лабиринт, в котором между двумя любыми клетками всегда существует единственный путь. </p><p>
Понятно, что в правильном лабиринте не может быть замкнутых маршрутов, то есть все стенки обязательно связаны друг с другом. Иначе мы сможем двумя способами прийти в одну и ту же клетку, двигаясь кольцевым маршрутом в разных направлениях.</p><p>
Закольцованных стенок в правильном лабиринте тоже не может быть: иначе какие-то клетки окажутся отрезанными от остального лабиринта, и пройти к ним будет нельзя. </p><p>
В правильном лабиринте любая клетка может быть "входом", и любая клетка может быть "выходом" - ведь из любой клетки в любую путь единственный. Но мы для определённости будем считать началом лабиринта верхнюю левую клетку, а "выходом" - правую нижнюю.</p>

<h3>Как описать лабиринт в программе?</h3>
<p>Пусть нам нужно описать лабиринт шириной <strong>m</strong> и высотой <strong>n</strong> клеток. Рассмотрим два способа описания лабиринта. <p><em>Первый способ.</em> Нам понадобится двумерный массив (список) <strong>m*n</strong>, чтобы записать информацию про каждую клетку. Но из каждой клетки может быть четыре выхода в разных направлениях. Так что элементами этого двумерного списка будут списки из 4-х логических элементов, указывающих, можно ли пройти в соседнюю клетку сверху, справа, снизу или слева.</p><p>
В начальный момент проходов межлу клетками нет. Чтобы создать лабиринт, нам придётся по определённым правилам "прогрызать" проходы в стенках. Другой способ - наоборот, в пустом пространстве лабиринта строить стены. Заметим, что если прорезать во внешней стене "вход", то стены лабиринта (если сделать их толстыми и прорезать внутри сквозные ходы) тоже будкт представлять собой правильный лабиринт.</p><p>
<em>Второй способ.</em> Рассмотрирм массив узлов, в которых соединяются стенки, разделяющие клетки лабиринта. В лабиринте размером <strong>m*n</strong> клеток будет <strong>(m+1)*(n+1)</strong> узлов. Для каждого из узлов придётся задать 4 логических значения, говорящих о том, отходит от него в одном из четырёх направлений стенка, или нет. для определённости пронумеруем направления по часовой стрелке, начиная с направления "вверх": "вверх" - 0, "вправо" - 1, "вниз" - 2, "влево" - 3. Это будут номера элементов списка стенок, выходящих из одного узла. Если стенка есть, элемент равен <strong>True</strong>, если нет - <strong>False</strong> (можно и наоборот, главное - не запутаться).</p><p>
Понятно, что информация про одну и ту же стенку будет записана дважды, поскольку каждая стенка соединяет между собой ровно два узла. Ну и ладно, так удобнее. Надо только не забывать добавлять связывающую стенку к каждому из узлов.</p><p>
<em>Как правильно задать начальный двумерный массив?</em> - Используйте генератор списков с конструкцией <strong>for</strong>, например:</p><p>
<pre>
points = [[[False, False, False, False] for i in range(m + 1)] for j in range(n + 1)]
</pre></p><p>
<strong>Внимание!</strong> Выражение типа</p><p>
<pre>
a = [[0] * m] * n
</pre>
</p><p>
приведёт к ошибке! (Какой?)</p>

<h3>Создание новой стенки</h3>
<p>Сначала попробуем написать программу, которая рисует неслучайный правильный лабиринт, а потом добавим в неё случайность.</p><p><img src='labirint2.png' align='right'></p><p>
В самом начале уже есть стенки по краям лабиринта. Чтобы исключить выход за пределы лабиринта, просто скажем, что из крайних точек наружу стенки уже построены, а потом не будем их рисовать.</p>
<p><strong>A. </strong>Создайте трёхмерный список для хранения информации об узлах лабиринта, задайте в нём начальные значения. Вначале все внешние узлы соединены между собой, из них торчат стенки наружу. Все внутренние узлы ни с чем пока не соединены.</p>

<p>
<hr>
Поскольку все стенки соединены между собой, новую стенку мы можем строить только от тех точек, в которых уже есть хотя бы одна стенка. Нам понадобится специальный список <strong>active</strong> (одномерный), чтобы хранить в нём те точки, от которых можно продолжать строительство стенок.</p>
<p><strong>В. </strong>Создайте список <strong>active</strong> и внесите в него все точки, от которых можно начинать строительство стен (в начальный момент это все точки внешних стенок, кроме угловых). Точка - это кортеж из двух чисел, добавлять его надо так:</p><p>
<pre>
active.append((i, j))
</pre>
</p>
<hr>
<p><img src='labirint3.png' align='right'></p>
<p>
<em>Куда можно строить новую стенку?</em> - Давайте зададим вопрос по-другому: <em>"Куда нельзя?"</em>
</p><p>1) в сторону узла, который уже соединён с данным узлом стенкой.
</p><p>2) в сторону узла, из которого уже выходит хотя бы одна стенка (иначе получатся стенки, замкнутые в кольцо, а это нарушит правильность лабиринта).
</p><p>Чтобы было удобно проверять, строили мы уже в данную точку стенку, или нет, следует создать специальный список (или множество) <strong>used</strong>, куда записывать все уже задействованные в строительстве стенок точки.</p><p>
Подумайте: <em>Можно ли объединить списки <strong>used</strong>  и <strong>active</strong> и использовать один список вместо двух? Есть ли причины, по которым лучше всё-таки использовать два разных списка?</em>
</p>
<p><strong>С. </strong>Создайте, если нужно, список (множество) <strong>used</strong> и заполните его начальными значениями. Напишите четыре функции: <strong>up(i, j), down(i, j), right(i,  j), left(i, j)</strong>, которые строят стенку из точки с координатами <strong>(i, j)</strong> соответственно вверх, вниз, вправо или влево. И выдают в ответе <strong>True</strong>, если стенка построена, и <strong>False</strong>, если в эту сторону стенку строить нельзя. <em>Какие действия необходимо выполнить программе, чтобы стенка была "построена"?</em></p>
<hr>
<h3>Алгоритмы построения лабиринта</h3>
<p><em>Как выбирать узел, из которого строить очередную стенку?</em>  Новая стенка всегда начинается c узла из списка <strong>active</strong>. Но мы можем разными способами брать элементы из этого списка: начиная с начала, начиная с конца, из середины, в случайном порядке. Случайную формулу тоже можно задать разными способами.</p><p>
Выбрав узел, мы можем построить из него сразу все возможные стенки, а можем - только одну, а потом сразу переходить к следующему узлу. Лабиринты при этом получатся немного разные.</p><p>
Выбрав узел, мы можем по-разному выбирать последовательность направлений, в которых пытаемся строить стенки: например, всегда по часовой стрелке или случайным образом.</p><p>
<strong>D. </strong>Напишите программу, которая будет в цикле перебирать по очереди все точки из списка <strong>active</strong> и строить из каждой все возможные стенки в соседние точки (сам список <strong>active</strong> в процессе строительства стенок будет увеличиваться). <em>Когда нужно будет остановить строительство?</em></p><p>
Напишите функцию, котрая по заданному трёхмерному списку <strong>points</strong> нарисует построенный лабиринт. Посмотрите на получившуюся картинку.</p><p>
Если для рисования лабиринта используется модуль <strong>tkinter</strong>, можно рисовать лабиринт по мере построения. Тогда будет интересно наблюдать за последовательностью действий. Дополнительно можно визуализировать "строителя" - например, перемещать цветной кружок к тому узлу, от которого программа в данный момент пытается строить стенку.
</p><p>
<em>Замечание:</em> Чтобы выполнить подряд несколько функций, удобно предварительно занести их имена в список (без скобок - тогда они не будут выполняться), например:</p><p>
<pre>
directions = [up, right, down, left]
</pre>
</p><p>
Позже можно будет вызывать эти функции в цикле, например:</p><p>
<pre>
for f in directions:
    f(i, j)
</pre>
</p><p>или	</p><p>
<pre>
for k in range(4):
    directions[k](i, j)
</pre>
</p><hr><p>
<strong>E. </strong> Напишите программу, которая будет в цикле перебирать в случайном порядке все точки из списка <strong>active</strong> и строить из каждой все возможные стенки в соседние точки. Нарисуйте получившийся лабиринт. </p><p>
Чтобы выбирать направления в случайном порядке, можно перемешивать элементы списка с помощью метода <strong>random.shuffle(list)</strong> (параметр этого метода - список, элементы которого будут перемешаны).</p><p>
Вычислите время выполнения программы для разных размеров лабиринта. Используйте функцию <strong>time.time()</strong> (модуль <strong>time</strong> нужно подгрузить в начале программы).</p><hr><p>
<strong>F. </strong>В процессе строительства стенок мы добавляем в список <strong>active</strong> новые узлы, до которых были достроены стенки. <em>Нужно ли удалять из этого списка какие-то узлы?</em> Измените программу так, чтобы те узлы, из которых уже заведомо нельзя строить стенки, из списка <strong>active</strong> автоматически удалялись. <em>Как изменится время работы программы?</em></p><hr><p>
<strong>G. </strong>Напишите программу, которая будет в цикле перебирать все точки из списка <strong>active</strong> и строить из каждой все возможные стенки в соседние точки - на этот раз с конца списка. Сделайте два варианта: когда направления перебираются всегда в одном и том же порядке, и когда порядок выбора направлений случаен. Нарисуйте получившиеся лабиринты.</p><hr><p>

<strong>Н. </strong>Наверное, вы заметили, что случайный лабиринт получается какой-то слишком простой. Путь из верхней левой клетки в правую нижнюю проходит близко к диагонали прямоугольника, и его легко проследить взглядом. Попробуйте придумать, как сделать лабиринт более сложным. 
</p>
<hr>
<p>

<strong>I. </strong>Пусть лабиринт задаётся не массивом узлов, а массивом клеток, каждая из которых ограничена стенками с четырёх сторон. Напишите программу генерации лабиринта для такого представления данных. Придумайте алгоритм, приводящий к созданию сложных лабиринтов.</p>
<hr>
<p>
<strong>J. </strong>Напишите функцию, которая записывает созданный лабиринт в текстовый файл. Придумайте формат такого файла, удобный для записи и для чтения. Напишите вторую функцию, которая прочитывает данные из файла и рисует по ним лабиринт. Можно использовать модуль PIL, чтобы нарисовать растровую картинку и сразу сохранить её на диск.
</p>
<hr>
<p>
<strong>K. </strong>В лабиринт можно добавить "запрещённые области", в которые звходить нельзя. Или, наоборот, больште "залы" из нескольких клеток, в которые ведут много коридоров. Подумайте, как сделать такие лабиринты, и какое представление данных будет удобней использовать.</p>
<hr>
</body>
</html>
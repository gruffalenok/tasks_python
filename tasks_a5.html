<html>
<head>
<meta charset="utf-8">
  <title>Упругий мячик</title>
<style>
   body {  font-size: 130%;
           margin-top: 2em;
           margin-left: 4em;
		   margin-right: 4em;}
   pre  {  background-color: #eee;
           padding-top: 10;
	       padding-bottom: 10;}
</style>   

</head>
<body>
<h2>Упругий мячик</h2>
<p>Ниже написан текст программы - заготовка для модели движущегося мячика, упруго отскакивающего от стенок.</p>
<p>Скопируйте к себе и запустите программу. Она должна реагировать на щелчок мышкой, на нажатие клавиш Escape и Enter.</p>

<pre>
from tkinter import *
import time  # модуль работы с временем

class Ball:
    # Задаём множество переменных, от которых зависит движение мячика, и функции, определяющие поведение модели.
    def __init__(self, canvas, vel_x, vel_y, x1_bound, y1_bound, x2_bound, y2_bound, x=250, y=250,
                 size=10, color='#ffcc00', step_time=0.03):
        # холст, на котором всё рисуется
        self.canvas = canvas
        # скорость мяча по х и по у
        self.vel_x = vel_x
        self.vel_y = vel_y
        # координаты мяча
        self.x = x
        self.y = y
        # границы прямоугольника, в котором движется мяч
        self.x1_bound = x1_bound
        self.y1_bound = y1_bound
        self.x2_bound = x2_bound
        self.y2_bound = y2_bound
        # радиус мячика
        self.size = size
        self.color = color
        self.step_time = step_time
        self.stop = False
        # Рисуем рамочку, внутри которой будет двигаться мячик
        # Рамка шире границ на радиус мячика
        self.canvas.create_rectangle(x1_bound - self.size, y1_bound - self.size, x2_bound + self.size,
                                     y2_bound + self.size, width=3)
        # создаём овал - изображение мяча, ссылка на который хранится в переменной self.oval
        self.oval = canv.create_oval(x - size, y - size, x + size, y + size, fill=color)


    def step(self):
        # функция step() должна перемещать мячик в новое положение и вычислять новую скорость

        # новые координаты = старые + скорость
        self.x, self.y = self.x + self.vel_x, self.y + self.vel_y
        # Функция move перемещает овал на заданный вектор
        self.canvas.move(self.oval, self.vel_x, self.vel_y)

        ################################################################################################################
        #  Мой код
        # Нужно изменить скорость, если координаты мячика выходят за пределы прямоугольника, заданного координатами
        # self.x1_bound, self.y1_bound,  self.x2_bound, self.y2_bound
        # Если есть сила тяжести, скорость нужно менять на каждом шаге, а не только при встрече со стенкой.
        ###############################################################################################################
        if self.x > self.x2_bound:
            self.stop = True
        ###############################################################################################################
        #  Конец моего кода
        ###############################################################################################################

        print(self.vel_x, self.vel_y, self.x, self.y)

    def new_pos(self, event):
        # функция new_pos() начинает эксперимент с начала. Начальное положение мячика указывает мышка,
        # координаты начальной скорости считываются с бегунков.
        x = event.x
        y = event.y
        self.canvas.move(self.oval, x - self.x, y - self.y)
        self.x = x
        self.y = y
        self.vel_x = scale1.get()
        self.vel_y = scale2.get()
        self.play()

    def play(self):
        # Функция play() запускает движение мячика, выполняя каждый шаг вычислений через заданные интервалы времени.
        while not self.stop:
            self.step()
            time.sleep(self.step_time)  # пауза step_time сек
            root.update()
        self.stop = False

    def pause(self, event):
        # Функция pause() останавлмвает движение
        self.stop = True

    def start(self, event):
        # Функция start() продолжает движение мячика
        self.play()


# Начало программы
# Ширина и высота холста
XMAX = 500
YMAX = 600
# Границы области, в которой движется мячик, отстоят от края ходста на расстояние margin
margin = 50
# Минимальное и максимальное значения на бегунках
MIN = -10
MAX = 10

# создаём графическое окно
root = Tk()
# создаём холст в окне
canv = Canvas(root, width=XMAX, height=YMAX, bg="lightblue")

# создаём объект класса Ball, задаём значения его переменных
ball = Ball(canv, vel_x=5, vel_y=3, x1_bound=margin, y1_bound=margin, x2_bound=XMAX - margin, y2_bound=YMAX - margin)

# Создаются две шкалы для задания координат скорости
scale1 = Scale(root, orient=VERTICAL, length=YMAX - 20,
               from_=MIN, to=MAX, tickinterval=0)
scale2 = Scale(root, orient=VERTICAL, length=YMAX - 20,
               from_=MIN, to=MAX, tickinterval=0)
scale1.set(5)
scale2.set(3)
# Созданные объекты размещаются в окне
canv.grid(row=0, column=0)
scale1.grid(row=0, column=1)
scale2.grid(row=0, column=2)

# Определяем, какой объект в окне отвечает на события клавиатуры
canv.focus_set()
# задаём действие для левой клавиши мыши
canv.bind("&lt;Button-1&gt;", ball.new_pos)
# действие для клавиши "Enter"
canv.bind("&lt;Return&gt;", ball.start)
# действие для клавиши "Escape"
canv.bind("&lt;Escape&gt;", ball.pause)

# выводим окно на экран
root.mainloop()
</pre>

<h4>Задание:</h4>
<p><strong>A. </strong> Измените программу так, чтобы мячик останавливался, долетев до любой из стенок.</p>
<hr>
<p><strong>B. </strong> Измените программу так, чтобы мячик упруго отскакивал от всех стенок и продолжал движение.</p>
<hr>
<p><strong>С. </strong> Добавьте силу тяжести: за равные интервалы времени вертикальная составляющая скорости будет меняться на заданную величину (у-составляющая скорости должна на каждом шаге немножко уменьшаться). Проверьте, как ведёт себя модель в течение некоторого времени. При упругих отскакиваниях мячик должен всегда подпрыгивать на одну и ту же высоту. Если это условие не выполняется, придумайте, что нужно исправить в модели.</p>
<h3>Указание:</h3>
<p>Чтобы вычислить новое положение мячика на следующем шаге (то есть через единичный интервал времени) при равномерном движении мы используем формулы: <br><i>x<sub>new</sub> = x<sub>old</sub> + vel_x<br>y<sub>new</sub> = y<sub>old</sub> + vel_y</i><br>
Но если скорость меняется, то какую скорость нужно подставлять в формулу: ту, которая была в начале этого интервала времени, или ту, которая стала в конце?</p>
<p>Попробуйте в своей модели по очереди реализовать оба варианта: 1) сначала вычисляем новую координату, потом вычисляем новую скорость; 2) сначала вычисляем новую скорость, затем вычисляем новую координату. Проверьте, как ведёт себя мячик в каждом из этих случаев. Как будет меняться со временем максимальная высота, на которую он подпрыгивает?</p>
<p>Чему равна средняя скорость мячика за единичный интервал времени? Попробуйте использовать в формуле для вычисления координаты среднюю скорость вместо начальной или конечной. Вычисляйте её "честно" по формуле <br><i>v<sub>average</sub> = (v<sub>old</sub> + v<sub>new</sub>):2</i>. <br>Обратите внимание, что за интервал, в котором происходит абсолютно упругое соударение, средняя скорость равна 0.  </p>
</p>
<hr>

<p><strong>D. </strong> Добавьте кнопку, включающую и выключающую рисование траектории мяча. Получите картинки траекторий мяча, двигающегося из одной точки с разными начальными скоростями (рассмотрите случаи, когда горизонтальные составляющие одинаковы, а вертикальные различны, и наоборот).<br> Ещё понадобится кнопка, стирающая все нарисованные траектории (<a href='https://younglinux.info/tkinter/canvasmeth.php'>используйте теги при рисовании отрезков</a>).</p>
<p><a href='https://younglinux.info/tkinter/grid'>Метод grid()</a> - размещение виджетов (кнопок, бегунков и пр.) в ячейках таблицы.</p>
<hr>
<p><strong>E. </strong> Добавьте бегунок, позволяющий задавать величину ускорения. Получите картинки траекторий мяча, двигающегося из одной точки с одинаковыми начальными скоростями, но пазными ускорениями.</p>
<hr>
<p><strong>D. "Пушка".</strong> Пушка находится в левом нижнем углу окна, цель - справа. На бегунках задаётся полная скорость ядра и угол от 0 до 90 градусов. Нужно поразить цель. Добавьте сопротивление воздуха.</p>
<hr>

<p><strong>Е. "Теннис".</strong> Добавьте сетку и ракетки-прямоугольники, которыми управляют игроки с клавиатуры.</p>
<hr>

</body>
</html>
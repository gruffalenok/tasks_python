<html>
<head>
<meta charset="utf-8">
  <title>Клеточный автомат Конвея (игра "Жизнь")</title>
<style>
   body {  font-size: 130%;
           margin-top: 2em;
           margin-left: 4em;
		   margin-right: 4em;}
   pre  {  background-color: #eee;
           padding-top: 10;
	       padding-bottom: 10;}
</style>   
 
</head>
<body>
<h2>Клеточный автомат Конвея (игра "Жизнь")</h2>

<p>Прочтите статью <a href='https://moodle.179.ru/pluginfile.php/7991/mod_resource/content/1/cellular_automaton_article.html' target='_blank'>Виртуальная жизнь клеточных автоматов</a>. Для описания состояний клеток мы будем использовать не двумерный массив, а <a href='https://informatics.mccme.ru/mod/book/view.php?id=6693' target='_blank'>множество</a> координат "живых" клеток.</p>
<h3>Клеточный автомат Конвея</h3>
<p>
1. Каждая клетка имеет одно из двух состояний - "живое" и "мертвое" (1 и 0). </p><p>
2. Правила, которые определяют состояние клетки в момент времени k+1, просты: </p><ul><li>
если живая клетка на такте k имеет меньше 2 и больше 3 соседей (в минимальной окрестности из восьми клеток), то на такте k+1 она умирает (здесь простая аналогия с реальной жизнью - недостаток питания или перенаселенность), </li><li>
в пустой клетке на такте k+1 появляется живая клетка, если у исходной клетки в минимальной окрестности ровно 3 соседа (три родителя!). </li></ul>
<h4>Задание:</h4>

<p><strong>A. </strong> Пусть имеется клетчатое поле рамером NX x NY клеток, каждая размером SIZE.
Каждая клетка имеет две координаты: от 0 до NX-1 и от 0 до NY-1. Координаты "живых" клеток будем хранить в множестве set_of_things. Например, если множество состоит из трёх элементов {(3, 3), (4, 3), (5, 3)}}, это значит, что клетки с координатами (3, 3), (4, 3), (5, 3) - "живые", а остальные - "мёртвые".</p>
<p>
Напишите <a href='https://younglinux.info/python/function.php' target='_blank'>функцию</a>  neighbours(x, y), которая вычисляет число "живых" соседей у клетки с координатами (x, y) (можно посчитать и саму клетку (x, y), если так удобнее). Проверьте работу функции (для этого в основной программе нужно задать непустое множество set_of_things и вызвать функцию neighbours(x, y) для разных значений x и y).</p>
<hr>
<p><strong>B. </strong> Напишите функцию create_new_things(), использующую функцию, возвращающую число "живых" соседей, которая будет вычислять множество "живых" клеток на следующем шаге. Проверьте работу функции. Например, если исходное множество было {(3, 3), (4, 3), (5, 3)}}, то новое будет {(4, 2), (4, 4), (4, 3)}, а на следующем шаге опять будет {(3, 3), (4, 3), (5, 3)}}.</p>
<hr>

<p><strong>С. </strong> Напишите функцию, которая рисует клетчатое поле рамером NX x NY клеток, каждая размером SIZE.
</p>
<hr>    
<p><strong>D. </strong>
Напишите функцию draw_things(), которая рисует кружочки в центре всех "живых" клеток (то есть всех клеток, координаты которых принадлежат множеству set_of_things (используйте цикл for).</p>
<p> Проверьте работу функции, вызвав её из основной программы (в программе нужно сначала задать непустое множество set_of_things). Проверьте работу всех написанных функций с помощью кнопки "Step", вызывающей функцию step(). </p>

<p>Шаблон программы, в которой необходимо дописать все функции:</p>
<pre>
from tkinter import *
from time import sleep

	
def neighbours(x, y):
# функция должна давать в ответе число "живых" соседей у клетки с координатами (x, y).
    return 0


def create_new_things():
# функция должна вычислять множество "живых" клеток на следующем шаге.
    new_things = set()
    
    print(new_things)
    return new_things


def draw_things():
# функция должна рисовать кружочки в центре всех "живых" клеток
    canv.delete('things') # стираются все старые кружочки
	
    canv.create_oval(100, 100, 110, 110, fill=color, tag='things') # пример рисования кружочка

    window.update()  # обновляется картинка в окне


def step():
# функция меняет состояние системы на новое 
# функция должна выключать режим редактирования начальных данных
    global set_of_things 
# переменную set_of_things нужно объявить глобальной, так как используется операция присваивания
    set_of_things = create_new_things()
    draw_things()
	

def add_thing(event):
# В режиме редактирования начальных данных (edit == True) функция должна добавлять 
# "живую" клетку в множество set_of_things, если её там ещё нет, 
# и рисовать соответствующий кружочек. Если же клетка с такими координатами "живая",
# она становится "мёртвой" и её кординаты удаляются из множества.
# На месте цветного кружочка рисуется кружочек фонового цвета.
    if not edit:
        return
    # event.x и event.y - координаты точки на холсте, в которой кликнули мышкой.
	
	print(set_of_things)


def run():
# функция должна показывать смену состояний системы, пока не будет нажата кнопка "Пауза".
    sleep(sleep_time) # функция sleep() из модуля time создаёт задержку в заданное число секунд.
        

def stop():
# функция меняет значение глобальной переменной pause, это должно привести к приостановке
# показа смены состояний
    global pause
    pause = True


# Начало основной программы 
XN = 50
YN = 50
SIZE = 10
edit = True
set_of_things = set()
color = 'green'
bgcolor = 'lightblue'
pause = False
sleep_time = 0.2

# Создаётся графическое окно, на которое ссылается переменная window
window = Tk()

# Создаётся холст размером XMAX на YMAX, на который ссылается переменная canv
canv = Canvas(window, width=XN*SIZE, height=YN*SIZE, bg=bgcolor)
button1 = Button(window, text='Step', command=step)
button2 = Button(window, text='Run', command=run)
button3 = Button(window, text='Pause', command=stop)
# Холст и кнопки размещаются в окне
canv.grid(row=0, column=0, columnspan=3)
button1.grid(row=1, column=0)
button2.grid(row=1, column=1)
button3.grid(row=1, column=2)

# метод bind() обрабатывает события, связанные с действиями пользователя:
# при нажатии на левую клавишу мышки вызывается функция add_thing() и создаётся объект event,
# который передаётся ей в качестве параметра
canv.bind('&lt;Button-1&gt;', add_thing)

# Графическое окно выводится на экран и готово реагировать на события
window.mainloop()
</pre>

<hr>
<p><strong>Е. </strong>Напишите функцию add_thing(event), которая в режиме редактирования исходных данных по клику мышки добавляет в множество set_of_things новую "живую" клетку или удаляет её, если она там уже есть. Функция должна визуализировать выполняемые действия: рисовать соответствующий кружочек, или "стирать" его (закрывать кружочком фонового цвета). Функция step() должна выключать режим редактирования.</p>
<hr>    
<p><strong>F. </strong>Напишите функцию run(), которая через каждые sleep_time секунд будет показывать смену состояний системы, пока не нажмут кнопку "Пауза".</p>
<hr>    
<p><strong>G. </strong>Напишите функцию, которая будет записывать начальное (текущее?) состояние системы в <a href='https://informatics.mccme.ru/mod/book/view.php?id=11513' target='_blank'>текстовый файл</a>. В первой строчке файла должно стоять число "живых" клеток. В каждой следующей строчке файла должно стоять два числа, разделённые пробелом: координаты "живых" клеток.</p>    
<p>Напишите функцию, считывающую из файла сохранённое начальное состояние. Добавьте в окно кнопки, связанные с этими функциями.</p>
<hr>   
</body>
</html>
<html>
<head>
<meta charset="utf-8">
<title> Шахматы </title>
<style>
   body {  font-size: 130%;
           margin-top: 2em;
           margin-left: 4em;
		   margin-right: 4em;}
   pre  {  background-color: #eee;
           padding-top: 10;
	       padding-bottom: 10;}
</style>   
</head>
<body>
<h2>Шахматы</h2>
<p>Ниже написан текст программы - заготовка для шахматного "задачника". Скопируйте в новый файл и запустите её. Программа рисует одну клеточку шахматной доски (не там, где надо!) и считывает координаты курсора, когда в окне щёлкают мышкой. Про управление объектами на холсте в модуле tkinter можно почитать <a href='https://younglinux.info/tkinter/canvasmeth' target='_blank'>здесь</a>.</p>
<p>Программа должна делать следующее (но пока не делает):</p>
<ul>
<li>рисовать шахматную доску (с полями),</li>
<li>выделять красной рамкой ту клеточку, на которой щёлкнули мышкой,</li>
<li>печатать, какие фигуры могут ходить из одной выделенной клетки в другую, а какие - нет.</li>
</ul>

<pre>
from tkinter import *


def draw_board(size, margin, color1, color2):
    ###########################################################################
    # Напишите тело функции, которая рисует на холсте canvas шахматную доску
    # с размером клеток size и цветами клеток color1 и color2.
    # Клетки нужно рисовать с отступом margin от начала координат
    # (одинаковым по x и по y).
    ###########################################################################
    canv.create_rectangle(0, 0, size, size, fill=color1)
    ############################################################################
    # конец моего кода
    ############################################################################


def num_сell(x, y):
    ############################################################################
    # Напишите тело функции, которая получает на вход координаты курсора x, y
    # и вычисляет позицию клетки x_num, y_num, в которой находится курсор.
    # Позиция левой верхней клетки 0, 0.
    # Известен размер клетки sise и величина полей margin
    # Переменная out должна принимать значение True в том случае,
    # если курсор оказался за пределами доски - на полях.
    ############################################################################
    x_num = 0
    y_num = 0
    out = False
    ############################################################################
    # конец моего кода
    ############################################################################
    return x_num, y_num, out


def select_cell(num_x, num_y, out):
    global x1, x2, y1, y2, selected1, selected2
    if out:
        return
    #####################################################################################
    # Если начало хода ещё не указано, функция должна менять значения х1, у1 и selected1.
    # И обводить рамочкой клетку начала хода (рамки, показывающие предыдущий ход, исчезают).
    # Если начало хода уже указано, функция должна менять значения х2, у2 и selected2.
    # И обводить рамочкой клетку конца хода (рамка, показывающая начало хода, остаётся).
    # А потом запускать проверку, например, check(x1, y1, x2, y2)
    #####################################################################################


def select(event):
    # event.x, event.y - координаты курсора мыши в момент нажатия на клавишу
    num_x, num_y, out = num_сell(event.x, event.y)
    select_cell(num_x, num_y, out)


def check_rook(x1, y1, x2, y2):
    #####################################################################################
    # Напишите тело функции, которая получает на вход позиции двух клеток (две пары чисел от 1 до 7), и
    # возвращает значение True, если ладья из первой клетки за 1 ход может попасть во вторую,
    # возвращает значение False, если ладья из первой клетки во вторую за 1 ход попасть не может.
    #####################################################################################
    return False
    ######################################################################################
    # конец моего кода
    ######################################################################################


def check_bishop(x1, y1, x2, y2):
    #####################################################################################
    # Напишите тело функции, которая получает на вход позиции двух клеток (две пары чисел от 1 до 7), и
    # возвращает значение True, если слон из первой клетки за 1 ход может попасть во вторую,
    # возвращает значение False, если слон из первой клетки во вторую за 1 ход попасть не может.
    #####################################################################################
    return False
    ######################################################################################
    # конец моего кода
    ######################################################################################


def check_knight(x1, y1, x2, y2):
    #####################################################################################
    # Напишите тело функции, которая получает на вход позиции двух клеток (две пары чисел от 1 до 7), и
    # возвращает значение True, если конь из первой клетки за 1 ход может попасть во вторую,
    # возвращает значение False, если конь из первой клетки во вторую за 1 ход попасть не может.
    #####################################################################################
    return False
    ######################################################################################
    # конец моего кода
    ######################################################################################


def check_king(x1, y1, x2, y2):
    #####################################################################################
    # Напишите тело функции, которая получает на вход позиции двух клеток (две пары чисел от 1 до 7), и
    # возвращает значение True, если король из первой клетки за 1 ход может попасть во вторую,
    # возвращает значение False, если король из первой клетки во вторую за 1 ход попасть не может.
    #####################################################################################
    return False
    ######################################################################################
    # конец моего кода
    ######################################################################################


def check_queen(x1, y1, x2, y2):
    #####################################################################################
    # Напишите тело функции, которая получает на вход позиции двух клеток (две пары чисел от 1 до 7), и
    # возвращает значение True, если ферзь из первой клетки за 1 ход может попасть во вторую,
    # возвращает значение False, если ферзь из первой клетки во вторую за 1 ход попасть не может.
    #####################################################################################
    return False
    ######################################################################################
    # конец моего кода
    ######################################################################################


def check(x1, y1, x2, y2):
    ######################################################################################
    # Напишите тело функции, которая получает на вход позиции двух клеток (две пары чисел от 1 до 7),
    # а на выходе печатает
    # список шахматных фигур, которые могут за 1 ход попасть из первой клетки во вторую,
    # и список шахматных фигур, которые не могут за 1 ход попасть из первой клетки во вторую.
    # Используйте вызов функций, вычисляющих возможность хода для каждой фигуры в отдельности.
    ######################################################################################
    print(x1, y1, x2, y2)
    print('Так ходить могут:')
    if check_rook(x1, y1, x2, y2):
        print('Ладья')
    print('Так ходить не могут:')

    ######################################################################################
    # конец моего кода
    ######################################################################################


# начало программы

size = 50  # Размер клетки
margin = 25  # Ширина полей
color_black = '#784421'  # Цвет чёрной клетки
color_white = '#ffcc00'  # Цвет белой клетки
x1 = x2 = y1 = y2 = 0
selected1 = False  # Выделена клетка - начало хода
selected2 = False  # Выделена клетка - конец хода

Size_board = size * 8 + margin * 2  # Размер шахматной доски (ширина и высота холста)
root = Tk()  # Создаётся графическое окно
# Создаётся объект класса Canvas (холст), занимающий всё окно целиком
canv = Canvas(root, width=Size_board, height=Size_board, bg='#d38d5f')
canv.pack()  # Холст размещается в окне

draw_board(size, margin, color_black, color_white)  # Вызывается функция  draw_board()

# метод bind() обрабатывает события, связанные с действиями пользователя:
# при нажатии на левую клавишу мышки вызывается функция select() и создаётся объект event,
# который передаётся ей в качестве параметра
canv.bind("&lt;Button-1&gt;", select)
root.mainloop()  # Графическое окно выводится на экран и готово реагировать на события

</pre>

<p><b>A. </b> Чтобы научить программу рисовать шахматную доску, нужно изменить функцию <em><strong>draw_board(),</strong></em> которая должна рисовать на холсте <em><strong>canv</strong></em> шахматную доску с размером клеток <em><strong>size</strong></em> и цветами клеток <em><strong>color1</strong></em> и <em><strong>color2</strong></em>. Клетки нужно рисовать с отступом <em><strong>margin</strong></em> от начала координат (одинаковым по x и по y). </p>

<p><strong>Важно!</strong> Следует следить за отступами: тело функции сдвинуто на 4 пробела вправо относительно инструкции <strong><em>def</em>,</strong> определяющей функцию.</p>
<hr>
<p><b>B. </b>  Чтобы научить программу выделять клетку, в которую щёлкнули курсором, нужно переделать функцию <strong><em>num_сell()</em></strong>. У этой функции <em><strong>num_сell</strong> </em> два параметра: <strong><em>x</em></strong> и<em> <strong>y</strong></em> - это координаты курсора, которые получает функция.</p>
<p>Функция должна вычислять значения трёх переменных: <strong><em>x_num</em></strong>  - номер колонки, в которой находится клетка, начиная с 0), <strong><em>y_num</em></strong> - номер ряда, в котором находится клетка, начиная с 0 и <strong><em>out</em></strong> - логическое значение, равное <em><strong>True</strong></em>, если курсор оказывается за границами шахматной доски (на полях).</p>

<p>В последней строчке команда <strong><em>return</em></strong> возвращает значения <strong><em>x_num</em></strong>, <strong><em>y_num</em></strong> и <strong><em>out</em></strong>. Эту строчку менять не надо!</p>
<hr>
<p><b>C.</b> Чтобы задать ход, необходимо выделить две клетки: начало (<strong><em>х1</em></strong> и <strong><em>у1</em></strong>) и конец хода (<strong><em>х2</em></strong> и <strong><em>у2</em></strong>). После того, как выделено начало, переменную <strong><em>selected1</em></strong> нужно сделать <em><strong>True</em></strong> и следующим "кликом" мышки задавать уже конец хода. За эти действия отвечает функция <strong><em>select_cell()</em></strong>. </p>
<p>Если начало хода ещё не указано, функция должна менять значения <strong><em>х1, у1</em></strong> и <strong><em>selected1</em></strong> и обводить рамочкой клетку начала хода (рамки, показывающие предыдущий ход, исчезают).
Если начало хода уже указано, функция должна менять значения <strong><em>х2, у2</em></strong> и <strong><em>selected2</em></strong> и обводить рамочкой клетку конца хода (рамка, показывающая начало хода, остаётся).
А потом запускать проверку, например, <strong><em>check(x1, y1, x2, y2)</em></strong>.</p>
<hr>
<p><b>D. </b>  Чтобы программа печатала, какие фигуры могут ходить из одной выделенной клетки в другую, а какие - нет, нужно дописать функции <strong><em>check_rook(x1, y1, x2, y2), check_bishop(x1, y1, x2, y2), check_knight(x1, y1, x2, y2), check_king(x1, y1, x2, y2), check_queen(x1, y1, x2, y2)</em></strong>.
<p>Эти функции получают на вход координаты начальной и конечной клеток и должны давать в ответе <strong><em>True</em></strong> или <strong><em>False</em></strong>, в зависимости от того, может так ходить соответствующая шахматная фигура, или нет. Их должна вызывать функция  <strong><em>check(x1, y1, x2, y2)</em></strong> (её тоже нужно дописать),
которая печатает, какие фигуры могут ходить указанным образом, а какие - нет.</p>
<hr>
<p><b>Е. </b> Напишите программу, которая при клике мышкой в какой-нибудь клетке выделяет (обводит цветными рамочками или ещё как-то) все клетки, в которые из неё может пойти а) ладья, б) конь, в) ферзь, г) король.<p></p> Перед тем, как выделять соответствующие клетки, следует составить список с координатами клеток, в которые можно пойти. Заготовка для этой программы написана ниже. Функции  draw_board() и num_сell() нужно скопировать из своей программы (задачи А и В).
  </p>
 <p>
 <pre>
from tkinter import *


def draw_board(size, margin, color1, color2):
    ###########################################################################
    # Напишите тело функции, которая рисует на холсте canvas шахматную доску
    # с размером клеток size и цветами клеток color1 и color2.
    # Клетки нужно рисовать с отступом margin от начала координат
    # (одинаковым по x и по y).
    ###########################################################################
    canv.create_rectangle(0, 0, size, size, fill=color1)
    ############################################################################
    # конец моего кода
    ############################################################################


def num_сell(x, y):
    ############################################################################
    # Напишите тело функции, которая получает на вход координаты курсора x, y
    # и вычисляет позицию клетки x_num, y_num, в которой находится курсор.
    # Позиция левой верхней клетки 0, 0.
    # Известен размер клетки sise и величина полей margin
    # Переменная out должна принимать значение True в том случае,
    # если курсор оказался за пределами доски - на полях.
    ############################################################################
    x_num = 0
    y_num = 0
    out = False
    ############################################################################
    # конец моего кода
    ############################################################################
    return x_num, y_num, out

def create_allowed_moves(num_x, num_y):
    global allowed_moves
    #####################################################################################
    # Функция должна вычислить и записать в список allowed_moves
    # все клетки, в которые может ходить данная фигура (значение переменной chess_piece).
    #####################################################################################
	allowed_moves = []
	############################################################################
    # конец моего кода
    ############################################################################

	
def draw_allowed_moves(num_x, num_y):
    #####################################################################################
    # Функция должна отмечать клетку с номером (num_x, num_y) и - другим цветом -
    # все клетки, в которые может ходить данная фигура (значение переменной chess_piece).
    # Предполагается, что координаты этих клеток уже вычислены и записаны в список allowed_moves
    #####################################################################################
	canv.delete('selected_cells')
	canv.create_rectangle(size, size, size*2, size*2, outline='red', width=3, tags='selected_cells')
	############################################################################
    # конец моего кода
    ############################################################################


def select(event):
    # event.x, event.y - координаты курсора мыши в момент нажатия на клавишу
    num_x, num_y, out = num_сell(event.x, event.y)
	if not out:
	    create_allowed_moves(num_x, num_y)
        draw_allowed_moves(num_x, num_y)


def rook_moves():
    global chess_piece
    chess_piece = 'rook'
	canv.delete('selected_cells')
	text1.config(text="Ладья")
	
def knight_moves():
    global chess_piece
    chess_piece = 'knight'
	canv.delete('selected_cells')
	text1.config(text="Конь")
	
def king_moves():
    global chess_piece
    chess_piece = 'king'
	canv.delete('selected_cells')
	text1.config(text="Король")
	
def queen_moves():
    global chess_piece
    chess_piece = 'queen'
	canv.delete('selected_cells')
	text1.config(text="Ферзь")


# начало программы

size = 50  # Размер клетки
margin = 25  # Ширина полей
color_black = '#784421'  # Цвет чёрной клетки
color_white = '#ffcc00'  # Цвет белой клетки
x1 = x2 = y1 = y2 = 0
chess_piece = 'rook'
allowed_moves = []

Size_board = size * 8 + margin * 2  # Размер шахматной доски (ширина и высота холста)
root = Tk()  # Создаётся графическое окно
# Создаётся объект класса Canvas (холст), занимающий всё окно целиком
canv = Canvas(root, width=Size_board, height=Size_board, bg='#d38d5f')
# Создаются кнопки и надпись
# при нажатии на кнопку button1 запускается функция rook_moves()
button1 = Button(root, text="Ладья", command=rook_moves)  
button2 = Button(root, text="Король", command=king_moves)
button3 = Button(root, text="Ферзь", command=queen_moves)
button4 = Button(root, text="Конь", command=knight_moves)
text1 = Label(text="Ладья", font=("Comic Sans MS", 18, "bold"), bd=10)

# Созданные объекты размещаются в окне
text1.grid(row=0, column=0, columnspan=4)
canv.grid(row=1, column=0, columnspan=4)
button1.grid(row=2, column=0)
button2.grid(row=2, column=1)
button3.grid(row=2, column=2)
button4.grid(row=2, column=3)

draw_board(size, margin, color_black, color_white)  # Вызывается функция  draw_board()

# метод bind() обрабатывает события, связанные с действиями пользователя:
# при нажатии на левую клавишу мышки вызывается функция select() и создаётся объект event,
# который передаётся ей в качестве параметра
canv.bind("&lt;Button-1&gt;", select)
root.mainloop()  # Графическое окно выводится на экран и готово реагировать на события

</pre>

<hr>
<p><b>F. </b> Чему ещё нужно научить программу, чтобы с её помощью можно было решать шахматные задачи? Какие функции для этого нужно написать?  </p>
<hr>
</body>
</html>